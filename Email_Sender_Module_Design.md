# Email Sender Module - Design Document

## 1. Proposed Architecture

*   **Microservice Design:** The module will be implemented as a standalone microservice named `EmailSenderService`.
    *   **Responsibilities:**
        *   Accepting email sending requests.
        *   Queuing emails for delivery.
        *   Managing the sending process via a custom SMTP client logic.
        *   Handling retries and basic bounce information.
        *   Providing status updates.
        *   Implementing deliverability best practices (SPF, DKIM signing).
    *   **Technology Stack:** Can be implemented in Java, Python, or .NET, leveraging appropriate libraries for each. The design will be language-agnostic where possible, with specific library recommendations.
*   **Receiving Email Requests:**
    *   **Primary Method: API Endpoint:**
        *   A RESTful API (e.g., `POST /send_email`) will be the primary way to submit email requests.
        *   **Payload (JSON):**
            ```json
            {
              "request_id": "unique_identifier_for_tracking", // Optional, can be generated by service if not provided
              "from_address": "sender@example.com",
              "reply_to_address": "reply-to@example.com", // Optional
              "to_addresses": ["recipient1@example.net", "recipient2@example.org"],
              "cc_addresses": ["cc1@example.net"], // Optional
              "bcc_addresses": ["bcc1@example.net"], // Optional
              "subject": "Your Subject Line",
              "body_plain": "This is the plain text body.",
              "body_html": "<h1>This is the HTML body</h1><p>With a <a href='http://example.com'>link</a>.</p>", // Optional
              "attachments": [ // Optional
                {
                  "filename": "document.pdf",
                  "content_type": "application/pdf",
                  "data_base64": "BASE64_ENCODED_DATA_HERE" // For direct embedding
                },
                {
                  "filename": "report.docx",
                  "download_url": "https://example.com/downloads/report.docx" // For linking
                }
              ],
              "headers": { // Optional custom headers
                "X-Custom-Header": "Value"
              },
              "priority": "normal" // Optional: "high", "normal", "low"
            }
            ```
        *   **Response (Synchronous):**
            *   On successful queuing: `202 Accepted` with a `message_id` (generated by the service for tracking).
            *   On validation error: `400 Bad Request` with error details.
            *   On authentication/authorization error: `401 Unauthorized` or `403 Forbidden`.
    *   **Alternative Method: Message Queue (e.g., RabbitMQ, Kafka, AWS SQS, Azure Service Bus):**
        *   The `EmailSenderService` can also consume messages directly from a designated queue.
        *   The message payload would be identical to the API JSON payload.
        *   This is suitable for high-throughput scenarios or integrating with other backend systems that prefer queue-based communication.
        *   The choice of queue will be determined by the overall system architecture but RabbitMQ is a good general-purpose starting point.

## 2. Custom SMTP Client Implementation Details

The goal is to send emails directly to recipient MX servers, but also support sending via a pre-configured relay if necessary (e.g., for specific domains or during initial rollout/testing).

*   **Core SMTP Protocol Support:**
    *   Implementation of standard SMTP commands: `HELO`/`EHLO`, `MAIL FROM`, `RCPT TO`, `DATA`, `QUIT`, `RSET`, `NOOP`.
    *   Parsing and handling of SMTP server responses (status codes and messages).
    *   Support for ESMTP extensions advertised by servers (e.g., `PIPELINING`, `8BITMIME`, `SMTPUTF8` if feasible).
*   **DNS MX Record Lookup Strategy:**
    *   For a given recipient email address (e.g., `user@example.com`):
        1.  Extract the domain part (`example.com`).
        2.  Perform a DNS query for MX records of that domain.
        3.  Order the MX records by their preference value (lower is more preferred).
        4.  Attempt connection to the MX servers in order of preference.
    *   **Caching:** Implement DNS caching (with appropriate TTL handling) to reduce redundant lookups for frequently targeted domains.
    *   **Libraries:**
        *   Java: `javax.naming.directory.DirContext` (for JNDI DNS lookups), or libraries like `dnsjava`.
        *   Python: `dnspython`.
        *   .NET: `System.Net.Dns` or third-party libraries like `DnsClient.NET`.
*   **Connection Management:**
    *   **Connection Pooling (Future Enhancement):** For high-volume sending to common domains, consider connection pooling to reduce SMTP handshake overhead. Initially, connections can be established per attempt.
    *   **TLS/SSL:**
        *   Prioritize `STARTTLS` on the standard SMTP port (25 or 587).
        *   If `STARTTLS` is not offered or fails, and if configured, attempt connection via SMTPS (SSL/TLS directly on port 465, though this is less standard for server-to-server).
        *   Use system's trusted CA certificates for server certificate validation. Allow configuration for accepting self-signed certificates for specific relays if absolutely necessary (development/testing environments only).
    *   **Timeouts:** Implement configurable timeouts for connection, command execution, and data transmission.
*   **Basic SMTP Authentication:**
    *   Support `AUTH PLAIN` and `AUTH LOGIN` mechanisms.
    *   This is primarily for scenarios where the service might be configured to send through an authenticated relay server (e.g., a corporate SMTP server, SendGrid, AWS SES) instead of direct MX delivery.
    *   Credentials would be securely stored and configured per relay.
*   **Recommended Libraries (for core SMTP client logic):**
    *   **Java:** **Jakarta Mail (formerly JavaMail)**. It provides `SMTPTransport` which handles much of the SMTP protocol. For MX lookups and direct sending, custom logic or `dnsjava` would supplement it.
    *   **Python:** **`smtplib`** for SMTP client operations. `dnspython` for MX lookups. For advanced bounce handling (server-side), `aiosmtpd` could be used to build a custom SMTP listener for NDRs (see Bounce Handling).
    *   **.NET:** **MailKit**. Its `SmtpClient` is robust, supports `STARTTLS`, authentication, and many ESMTP extensions. It can be used for direct sending (with custom MX lookup logic) or relaying.

## 3. Queue Management System

*   **Choice of Persistent Queue Technology:**
    *   **RabbitMQ (Recommended):**
        *   **Pros:** Mature, feature-rich (persistent messages, dead-letter exchanges, flexible routing), good client library support for Java, Python, .NET. Supports message acknowledgments critical for reliable processing.
        *   **Cons:** Requires separate server setup and management.
    *   **Apache Kafka:**
        *   **Pros:** Extremely high throughput, durable, good for streaming.
        *   **Cons:** More complex to set up and manage than RabbitMQ, might be overkill if not already part of the infrastructure.
    *   **Database-backed Queue (e.g., using PostgreSQL, MySQL):**
        *   **Pros:** Can leverage existing database infrastructure. Simpler for very basic needs.
        *   **Cons:** Less efficient for high volume, requires careful implementation of locking and polling, can put extra load on the database. Not recommended for a high-performance email sender.
    *   **Initial Recommendation:** **RabbitMQ** for its balance of features, reliability, and relative ease of use.
*   **Detailed Retry Mechanisms:**
    *   **Message Structure in Queue:** The queued message should include the email data and metadata like `attempt_count`, `last_attempt_time`, `original_enqueue_time`.
    *   **Temporary Errors (e.g., SMTP 4xx codes, connection timeouts, DNS lookup failures):**
        *   Increment `attempt_count`.
        *   Re-queue the message with a delay.
        *   **Retry Intervals:** Exponential backoff is recommended (e.g., 1 min, 5 min, 15 min, 30 min, 1 hour, then every few hours).
        *   **Max Retries:** Configurable (e.g., 10-15 attempts or up to 24-48 hours).
        *   If max retries are exhausted, move the message to a "failed" or "dead-letter" queue and log a permanent failure.
    *   **Permanent Errors (e.g., SMTP 5xx codes - unknown user, domain not found, message rejected by policy):**
        *   Log the permanent failure immediately.
        *   Move the message to a "failed" queue (or dead-letter exchange in RabbitMQ).
        *   No further retries for this specific recipient for this message.
*   **Bounce Handling Strategy:**
    *   **Synchronous SMTP Rejections:**
        *   These are immediate `5xx` (permanent) or `4xx` (temporary) responses received during the SMTP session (`RCPT TO` or `DATA` phases).
        *   Handled directly by the SMTP client logic as described in "Retry Mechanisms."
        *   Status is updated in the tracking database immediately.
    *   **Asynchronous Non-Delivery Reports (NDRs) / Bounces:**
        *   These are emails sent back to the `MAIL FROM` address (or a custom `Return-Path`) after the initial SMTP session has closed.
        *   **Initial Implementation (Feasible):**
            *   Configure a dedicated mailbox (e.g., `bounces@yourdomain.com`) for the `Return-Path` header.
            *   Periodically, a separate process or a component within the `EmailSenderService` would connect to this mailbox (via POP3 or IMAP, using libraries like Jakarta Mail, MailKit, or Python's `poplib`/`imaplib`).
            *   Parse these NDR emails. Identifying the original message and recipient can be challenging but often involves parsing standard bounce formats (e.g., DSN - Delivery Status Notification, RFC 3464) or custom headers injected into the original outgoing email (e.g., `X-Message-ID`).
            *   Update the status of the original email in the tracking database.
        *   **Future Enhancements (More Complex):**
            *   **Custom SMTP Listener for Bounces:** Deploy a lightweight SMTP server (e.g., using Python's `aiosmtpd` or a simple Java SMTP server library) specifically to receive NDRs directly. This avoids polling a mailbox and allows real-time processing. This listener would parse the incoming NDR and update the database.
            *   **Advanced NDR Parsing:** Use specialized libraries or services for parsing various NDR formats, as they can be inconsistent across different mail servers.
            *   **Feedback Loop (FBL) Processing:** Register with major ISPs (Gmail, Outlook.com, Yahoo) for FBLs to receive reports about messages marked as spam by users. This requires specific email headers and an endpoint to receive these reports.
*   **Priority Settings and Concurrency Controls:**
    *   **Priority Queues:** RabbitMQ supports message priorities. The `EmailSenderService` can use separate queues for high, normal, and low priority emails, or a single queue with message priority properties.
    *   **Concurrency Controls:**
        *   **Per Service Instance:** Limit the number of concurrent SMTP connections a single instance of `EmailSenderService` can make (e.g., using a semaphore or a fixed-size thread pool).
        *   **Per Destination Domain (Future Enhancement):** Implement logic to limit concurrent connections and sending rates to specific recipient domains to avoid being flagged as spam (e.g., no more than X connections or Y messages/minute to `example.com`). This requires tracking active connections/rates per domain.

## 4. Status Tracking and Logging

*   **Database Schema (Conceptual - e.g., PostgreSQL/MySQL):**
    *   `emails` table:
        *   `id`: BIGSERIAL, Primary Key
        *   `message_id`: VARCHAR(255), Unique, Indexed (generated by service or from request)
        *   `request_id`: VARCHAR(255), Indexed (from initial API request, optional)
        *   `from_address`: VARCHAR(255)
        *   `subject`: TEXT
        *   `status`: VARCHAR(50) (e.g., "queued", "sending", "sent", "failed_temporary", "failed_permanent", "delivered_fbl_spam")
        *   `retry_count`: INTEGER, Default 0
        *   `last_attempt_time`: TIMESTAMP
        *   `queued_time`: TIMESTAMP, Default CURRENT_TIMESTAMP
        *   `sent_time`: TIMESTAMP, Nullable
        *   `error_message`: TEXT, Nullable (last error encountered)
        *   `priority`: VARCHAR(20), Default 'normal'
    *   `email_recipients` table:
        *   `id`: BIGSERIAL, Primary Key
        *   `email_id`: BIGINT, Foreign Key to `emails.id`
        *   `recipient_address`: VARCHAR(255)
        *   `recipient_type`: VARCHAR(10) ('to', 'cc', 'bcc')
        *   `status`: VARCHAR(50) (e.g., "queued", "sending", "sent", "failed_temporary", "failed_permanent", "bounced")
        *   `smtp_response_code`: INTEGER, Nullable
        *   `smtp_response_message`: TEXT, Nullable
        *   `last_update_time`: TIMESTAMP
    *   Indexes on `recipient_address` and `status` in `email_recipients` would be useful for querying.
*   **Logging Details:**
    *   **Comprehensive Logging:** Log all significant events using a structured logging format (e.g., JSON).
    *   **Events to Log:**
        *   Email request received (with critical parameters, excluding sensitive data like Base64 content directly).
        *   Email queued (with `message_id`).
        *   Attempting to send (with `message_id`, recipient, MX server).
        *   SMTP commands and responses (can be verbose, potentially enabled by a debug flag).
        *   Successful delivery to a recipient.
        *   Temporary failure (with error, `retry_count`).
        *   Permanent failure (with error).
        *   Message moved to dead-letter queue.
        *   Bounce received and processed.
        *   DKIM signing success/failure.
    *   **Log Levels:** Use appropriate log levels (INFO, WARN, ERROR, DEBUG).
    *   **Tools:** Standard logging libraries (Log4j2/SLF4j for Java, `logging` module for Python, Serilog/NLog for .NET).
*   **API for Status Querying:**
    *   `GET /status/{message_id}`: Returns the overall status of the email and the status for each recipient.
    *   `GET /status?recipient_email={email_address}`: (More advanced) Returns status for emails sent to a specific recipient.
    *   Response should include status, timestamps, and any error messages.

## 5. Email Content and Attachments

*   **MIME Message Construction:**
    *   Support `multipart/alternative` for sending both plain text and HTML versions of the email. The receiving client will choose which version to display.
    *   Support `multipart/mixed` when attachments are included.
    *   Correctly set `Content-Type` headers for all MIME parts.
    *   Handle character encodings properly (UTF-8 preferred for all text parts).
*   **Handling of Download Links:**
    *   If an attachment is specified with a `download_url`, the service will not embed the data.
    *   Instead, the URL will be inserted into the email body (plain and/or HTML) as a hyperlink.
    *   This is useful for very large files or for tracking downloads.
*   **Libraries for MIME Construction:**
    *   **Java:** **Jakarta Mail (MimeMessage, MimeBodyPart, MimeMultipart).**
    *   **Python:** **`email.mime` package** (`MIMEMultipart`, `MIMEText`, `MIMEApplication`, `MIMEImage`).
    *   **.NET:** **MimeKit** (comes with MailKit). It has comprehensive MIME creation capabilities (`MimeMessage`, `TextPart`, `MimePart`, `Multipart`).

## 6. Deliverability and Security Best Practices

*   **SPF (Sender Policy Framework):**
    *   **Implementation:** This is primarily a DNS setup. A TXT record needs to be created for the sending domain(s) (the domain in the `MAIL FROM` / `Return-Path` address).
    *   **Content:** The SPF record will list the IP addresses or hostnames of the `EmailSenderService` instances that are authorized to send email for the domain.
    *   **Responsibility:** While the service itself doesn't "implement" SPF, the deployment and operational procedures for the service must include guidance on setting up correct SPF records.
*   **DKIM (DomainKeys Identified Mail) Signing:**
    *   **Implementation:**
        1.  **Key Generation:** Generate a public/private key pair for DKIM signing.
        2.  **DNS Setup:** Publish the public key as a TXT record in DNS at a specific selector (e.g., `selector1._domainkey.yourdomain.com`).
        3.  **Signing Process:** Before sending an email, the `EmailSenderService` will:
            *   Construct the email message (headers and body).
            *   Canonicalize the headers and body according to DKIM specs.
            *   Generate a cryptographic signature of the canonicalized content using the private key.
            *   Add a `DKIM-Signature` header to the email, including the signature, domain, selector, and other parameters.
    *   **Libraries:**
        *   Java: Libraries like `java-dkim` or building upon BouncyCastle. Jakarta Mail itself does not have direct DKIM signing support, but can be used to add the header.
        *   Python: `dkimpy`.
        *   .NET: MailKit/MimeKit provides DKIM signing capabilities.
*   **DMARC (Domain-based Message Authentication, Reporting, and Conformance):**
    *   **Implementation:** This is also a DNS setup. A TXT record at `_dmarc.yourdomain.com`.
    *   **Content:** The DMARC record tells receiving servers what to do if SPF and/or DKIM checks fail (e.g., `p=none`, `p=quarantine`, `p=reject`). It also specifies addresses for receiving aggregate (`rua`) and forensic (`ruf`) reports.
    *   **Responsibility:** Operational procedure. The service should enable SPF and DKIM to make DMARC effective. Processing DMARC reports is a separate operational task to monitor deliverability.
*   **Rate Limiting:**
    *   **Internal Limiting:**
        *   Limit the number of concurrent connections per instance of `EmailSenderService`.
        *   Limit the number of messages processed from the queue per unit of time per instance.
    *   **Per-Domain Limiting (Future Enhancement):** Track sending rates to major recipient domains (Gmail, Outlook, Yahoo) and throttle sending if internal thresholds are exceeded to avoid being temporarily blocked. This is complex and requires distributed state if multiple sender instances are used.
*   **IP Reputation Management:**
    *   **Dedicated IP Addresses:** For high-volume sending, use dedicated IP addresses.
    *   **IP Warm-up:** Gradually increase sending volume from new IP addresses over days/weeks.
    *   **Monitoring Blacklists:** Regularly check if sending IPs are listed on major DNS blacklists (DNSBLs).
    *   **Handling Spam Complaints:** Process Feedback Loops (FBLs) and unsubscribe requests promptly.
    *   **Clean Mailing Lists:** Ensure recipients have opted-in. High bounce rates of unknown users can damage IP reputation.
    *   **Content Quality:** Avoid spammy content.
    *   **Reverse DNS (PTR Records):** Ensure sending IP addresses have valid PTR records that match the sending domain or a relevant subdomain.

This design document provides a comprehensive plan for the Email Sender Module. The choice of specific libraries and queue technologies will depend on the chosen programming language and existing infrastructure, but the principles outlined should guide development.The design document for the Email Sender Module has been successfully created. It covers the proposed microservice architecture, details for a custom SMTP client (including MX lookup, TLS, and authentication), queue management with retry and bounce handling strategies, status tracking, MIME message construction, and key deliverability/security best practices like SPF, DKIM, and DMARC.

I will now submit the report for this subtask.
