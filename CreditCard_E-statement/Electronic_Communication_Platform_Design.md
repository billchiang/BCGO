# Extending the System to an Electronic Communication Platform - Design Document

## 1. Generalized Communication Concept

*   **Generic "Communication Job" Structure:**
    To support multi-channel communication, a generalized "Communication Job" or "Message" abstraction is needed. This structure will be used internally to represent any outgoing communication, regardless of the channel.

    **`CommunicationJob` Attributes:**
    ```json
    {
      "job_id": "unique_job_identifier", // Generated by the system
      "correlation_id": "client_provided_correlation_id", // Optional, for client-side tracking
      "customer_id": "unique_customer_identifier", // Links to the customer profile/preferences
      "communication_type": "NOTICE_OF_SERVICE_OUTAGE", // Business-defined type, e.g., "INVOICE_NOTIFICATION", "PASSWORD_RESET", "MARKETING_PROMO"
      "priority": "normal", // "high", "normal", "low"
      "requested_channels": ["email", "sms"], // Optional: Client can suggest preferred channels
      "channel_constraints": { // Optional: Specific constraints for channels
        "sms": {
          "require_delivery_receipt": true
        }
      },
      "recipient_details_override": { // Optional: If provided, overrides stored customer contact details for this job
        "email_address": "override_recipient@example.com",
        "phone_number": "+15551234567", // E.164 format for SMS
        "app_push_token": "device_token_for_push"
      },
      "payload_data": { // Data to be used for personalizing templates
        "customer_name": "John Doe",
        "invoice_number": "INV12345",
        "invoice_amount": "USD 100.00",
        "invoice_due_date": "2025-02-15",
        "service_name": "Premium Subscription",
        "outage_start_time": "2025-01-20T14:00:00Z",
        "outage_end_time": "2025-01-20T16:00:00Z"
        // ... other relevant data points
      },
      "template_references": { // Channel-specific template identifiers
        "email": "template_email_service_outage_v1",
        "sms": "template_sms_service_outage_v1",
        "app_push": "template_push_service_outage_v1"
      },
      "metadata": { // Any additional metadata for logging or routing
        "source_system": "BillingSystem",
        "batch_id": "optional_batch_identifier"
      },
      "schedule_at": "2025-01-20T13:00:00Z", // Optional: If the job needs to be sent at a specific time
      "status": "PendingDispatch", // Internal status: e.g., PendingDispatch, Dispatched, ProcessedByChannel, FailedDispatch
      "created_at": "2025-01-15T12:00:00Z"
    }
    ```
    *   **`job_id`**: Unique identifier for tracking the entire communication request.
    *   **`customer_id`**: Key to fetch customer preferences and contact details.
    *   **`communication_type`**: Semantic type of the message, useful for routing, prioritization, and template selection rules.
    *   **`requested_channels`**: Allows the initiating system to suggest channels, but final decision will be by the Dispatch Service based on preferences.
    *   **`recipient_details_override`**: For cases where ad-hoc contact details are used instead of stored ones.
    *   **`payload_data`**: The actual content variables to be merged with templates.
    *   **`template_references`**: Specific template IDs for each potential channel. This allows different message structures optimized for each channel.

## 2. New Sender Microservices Design

These services will be similar in architecture to the `EmailSenderService`, focusing on a single channel.

### a. SMSSenderService

*   **Architecture:**
    *   A microservice responsible for sending SMS messages via one or more SMS gateway providers.
    *   It will accept "Send SMS" requests (derived from a `CommunicationJob` by the `DispatchService`) via an internal API or a dedicated message queue.
    *   It will manage interactions with the chosen SMS gateway(s).
*   **Integration with SMS Gateways:**
    *   **Primary Gateway Suggestion: Twilio API** (assuming it's a common choice). Other gateways like Vonage (Nexmo), Sinch, or local providers can be integrated similarly.
    *   The service will use the gateway's REST API for sending messages.
    *   API credentials (Account SID, Auth Token, Sender IDs/Phone Numbers) will be securely stored and configured.
    *   Abstract the gateway interaction to allow for potential future switching or addition of gateways (Adapter pattern).
*   **Key Functionalities:**
    *   **Sending SMS:**
        *   Receive recipient phone number (E.164 format), message content (from a template), and sender ID.
        *   Make API calls to the SMS gateway.
        *   Handle API responses (success, failure, queued by gateway).
    *   **Status Handling:**
        *   Receive synchronous status from the gateway API call.
        *   Receive asynchronous status updates via webhooks provided by the gateway (e.g., "sent", "delivered", "failed", "undelivered"). This requires the `SMSSenderService` to expose a webhook endpoint that the gateway can call.
        *   Update the status of the SMS in a dedicated database table, linking back to the original `CommunicationJob`'s `job_id` or a sub-task ID.
    *   **Template Processing (Simple Text):**
        *   SMS templates will primarily be simple text messages, possibly with placeholders for `payload_data`.
        *   The service will perform basic variable substitution in the text template.
        *   Example SMS Template: `Dear {{customer_name}}, your invoice {{invoice_number}} for {{invoice_amount}} is due on {{invoice_due_date}}. View: {{short_url}}`
    *   **Short URL Integration (Optional):** For including links in SMS (which have character limits), integrate with a URL shortening service.
    *   **Character Encoding & Concatenation:** Handle message length limits, character encoding (GSM-7, UCS-2), and message concatenation for longer texts if supported/configured.
    *   **Logging:** Detailed logs of requests, gateway interactions, and status updates.

### b. AppPushService

*   **Architecture:**
    *   A microservice for sending push notifications to mobile applications.
    *   It will accept "Send Push Notification" requests (derived from a `CommunicationJob`) via an internal API or a message queue.
    *   It will manage interactions with Firebase Cloud Messaging (FCM) for Android and Apple Push Notification service (APNs) for iOS.
*   **Integration with FCM/APNs:**
    *   **FCM (Firebase Cloud Messaging):**
        *   Use Firebase Admin SDKs (Java, Python, Node.js, Go, C#) or FCM HTTP v1 API.
        *   Requires server keys/credentials for authenticating with FCM.
    *   **APNs (Apple Push Notification service):**
        *   Use APNs libraries (e.g., based on HTTP/2 protocol).
        *   Requires Apple Push Notification Keys (.p8 file) or certificates (.p12).
    *   The service will need to store and manage these platform-specific credentials securely.
    *   It will need to handle platform-specific payload structures.
*   **Key Functionalities:**
    *   **Sending Push Notifications:**
        *   Receive recipient device token(s), platform (Android/iOS), message content (title, body, custom data from a template).
        *   Construct the appropriate payload for FCM or APNs.
        *   Make API calls to the respective push notification service.
        *   Handle API responses (success, failure, invalid tokens).
    *   **Status Handling:**
        *   Receive synchronous status from FCM/APNs API calls.
        *   FCM provides some delivery status via the FCM API or Firebase console.
        *   APNs provides limited feedback (e.g., if a token is invalid). True "delivered" status is not always available directly from APNs in the same way as SMS.
        *   Update status in a database, linking to the `CommunicationJob`.
        *   Handle token lifecycle management (e.g., feedback from FCM/APNs about invalid or unregistered tokens should trigger updates in the `CustomerProfileService` to remove or mark those tokens).
    *   **Template Processing (Structured Content):**
        *   Push notification templates can be more structured (title, body, image URL, deep link URL, custom key-value pairs).
        *   Templates will define these fields with placeholders for `payload_data`.
        *   Example Push Template (JSON-like structure):
            ```json
            {
              "title": "Invoice Due: {{invoice_number}}",
              "body": "Hi {{customer_name}}, your invoice for {{invoice_amount}} is due on {{invoice_due_date}}.",
              "image_url": "{{company_logo_url}}", // Optional
              "deep_link": "myapp://invoices/{{invoice_id}}",
              "custom_data": {
                "invoice_id": "{{invoice_id}}",
                "category": "billing"
              }
            }
            ```
    *   **Logging:** Detailed logs of requests, platform interactions, and status updates.

## 3. Customer Preference Management

*   **Service Name:** `CustomerProfileService` (or `PreferenceService` if solely focused on preferences). Let's assume `CustomerProfileService` as it might hold other profile info.
*   **Data Model (Conceptual - e.g., NoSQL like MongoDB or Relational):**
    *   **`CustomerProfile` Collection/Table:**
        *   `customer_id`: String (Primary Key)
        *   `contact_details`: Array of objects
            *   `channel`: String ("email", "sms", "app_push", "voice", "whatsapp")
            *   `address`: String (e.g., email address, phone number in E.164, device token)
            *   `verified`: Boolean
            *   `primary`: Boolean (primary contact for this channel)
            *   `added_at`: Timestamp
            *   `last_verified_at`: Timestamp (if verification process exists)
        *   `communication_preferences`: Array of objects
            *   `communication_type`: String (e.g., "INVOICE_NOTIFICATION", "MARKETING_PROMO", "SERVICE_UPDATES")
            *   `allowed_channels`: Array of strings (e.g., ["email", "app_push"]) - Channels customer *permits* for this type.
            *   `preferred_channel`: String (e.g., "email") - Customer's top choice if multiple allowed.
            *   `opt_in_status`: Boolean (true if opted-in, false if opted-out for this type)
            *   `opt_in_source`: String (e.g., "WebAppSignup", "SupportCall")
            *   `opt_in_timestamp`: Timestamp
            *   `last_updated_timestamp`: Timestamp
        *   `global_unsubscribe_all`: Boolean (master opt-out from all non-transactional communications)
        *   `consent_records`: Array of objects (for GDPR/PDPA)
            *   `consent_type`: String (e.g., "marketing_emails", "product_update_sms")
            *   `granted`: Boolean
            *   `timestamp`: Timestamp
            *   `source`: String (e.g., "PreferenceCenterWebApp", "InitialSignupForm")
            *   `consent_document_version`: String (version of privacy policy/terms customer agreed to)
        *   `created_at`: Timestamp
        *   `updated_at`: Timestamp
*   **APIs:**
    *   `POST /customers`: Create a new customer profile.
    *   `GET /customers/{customer_id}`: Retrieve a customer's full profile (contact details, preferences, consent).
    *   `PUT /customers/{customer_id}`: Update overall customer profile information.
    *   `POST /customers/{customer_id}/contact_details`: Add a new contact detail (email, phone, device token).
        *   May trigger verification flow (e.g., send OTP for phone, verification email).
    *   `PUT /customers/{customer_id}/contact_details/{contact_id}`: Update a specific contact detail (e.g., mark as verified, set as primary).
    *   `DELETE /customers/{customer_id}/contact_details/{contact_id}`: Remove a contact detail.
    *   `GET /customers/{customer_id}/preferences`: Retrieve communication preferences.
    *   `PUT /customers/{customer_id}/preferences`: Update communication preferences (e.g., for different `communication_type`s, set allowed/preferred channels, opt-in/out).
    *   `GET /customers/{customer_id}/consent`: Retrieve consent records.
    *   `POST /customers/{customer_id}/consent`: Record a new consent status.
*   **Integration:**
    *   The `DispatchService` will query this service to get customer preferences and valid contact details.
    *   The `AppPushService` will need to update this service when a push token becomes invalid.

## 4. Channel Selection and Dispatch Logic

*   **Service Name:** `DispatchService` (or this logic can be a core part of the existing `BatchOrchestrationService` or a new `CommunicationOrchestrator`). For clarity, let's define it as a distinct logical component, `DispatchService`.
*   **Responsibilities:**
    *   Accepting a `CommunicationJob`.
    *   Enriching the job with customer preferences and contact details from `CustomerProfileService`.
    *   Applying rules and channel availability to select the most appropriate channel(s).
    *   Transforming the generic `CommunicationJob` into channel-specific requests.
    *   Dispatching these requests to the respective sender microservices (EmailSender, SMSSender, AppPushService) via their queues or APIs.
*   **Detailed Logic for Channel Selection:**
    1.  **Receive `CommunicationJob`:**
    2.  **Fetch Customer Profile:** Query `CustomerProfileService` using `customer_id`.
        *   If profile not found, or no valid contact details, job may fail or go to an exception queue.
    3.  **Check Global Unsubscribe:** If `global_unsubscribe_all` is true and the `communication_type` is non-transactional (e.g., "MARKETING_PROMO"), block sending on all but essential channels (if any).
    4.  **Filter by `communication_type` Preferences:**
        *   Find the preference setting for the job's `communication_type`.
        *   If customer has explicitly opted-out (`opt_in_status` is false) for this `communication_type`, block sending unless it's a legally mandated transactional message (requires clear definition of which types are mandatory).
        *   Get the list of `allowed_channels` and the `preferred_channel` for this `communication_type`.
    5.  **Consider `requested_channels` (from job):** If the job specified `requested_channels`, these can be used as a hint, but customer preferences take precedence.
    6.  **Channel Availability & Validity:**
        *   For each potential channel (derived from allowed/preferred):
            *   Check if a valid and verified contact address/token exists for that channel in the customer's profile (or was provided in `recipient_details_override`).
            *   Check if channel-specific templates are defined in `template_references`.
            *   (Future) Check real-time channel status (e.g., if SMS gateway is down, this channel is temporarily unavailable).
    7.  **Prioritization and Selection (Example Logic):**
        *   **Rule 1: Explicit Customer Preference:** If a `preferred_channel` is set for the `communication_type`, and it's valid and available, select it.
        *   **Rule 2: Client Requested Channels:** If no explicit customer preference, consider channels from `CommunicationJob.requested_channels` that are also in the customer's `allowed_channels` and are valid/available.
        *   **Rule 3: Default Channel Order (Configurable):** If no specific preference or request, use a system-defined default channel order (e.g., AppPush > Email > SMS) for this `communication_type`, selecting the first one that is allowed, valid, and available.
        *   **Rule 4: Mandatory Communications:** For certain critical `communication_type`s (e.g., "SECURITY_ALERT", "LEGAL_NOTICE"), the system might override some preferences to ensure delivery via at least one reliable channel (e.g., Email). This needs careful legal and business definition.
    8.  **Fallback Strategy:**
        *   If the primary selected channel fails synchronously during dispatch (e.g., `SMSSenderService` reports immediate invalid number before even trying gateway), the `DispatchService` *could* attempt a fallback.
        *   Example: If preferred AppPush fails due to invalid token at dispatch time, fallback to Email if allowed and available.
        *   Fallbacks for asynchronous failures (e.g., an SMS is hard bounced hours later) are more complex and usually handled by retry logic within the channel sender or by triggering a new `CommunicationJob` for a different channel based on the bounce.
    9.  **Prepare Channel-Specific Request:**
        *   For the selected channel(s), extract the relevant template ID from `template_references`.
        *   Create the specific payload for the sender service (e.g., for SMS, just the phone number and text content; for Email, the full structure).
    10. **Dispatch:** Send the request to the appropriate sender service's queue or API.
*   **Integration:**
    *   Receives jobs from API endpoints (for single requests) or from the `BatchOrchestrationService` (for batch jobs).
    *   Queries `CustomerProfileService`.
    *   Sends messages to `EmailSenderService`, `SMSSenderService`, `AppPushService`.

## 5. Template Management Enhancements

*   **`TemplateManagementService` Modifications:**
    *   The existing `TemplateManagementService` (designed for AFP/Email) needs to be generalized.
    *   **Data Model Extension:**
        *   The `Template` entity should include a `channel_type` attribute (e.g., "email", "sms", "app_push", "afp").
        *   The `content` field might need to store different structures based on `channel_type`:
            *   Email: HTML content, plain text content, subject.
            *   SMS: Text content string.
            *   App Push: JSON structure for title, body, data payloads, deep links.
            *   AFP: Reference to the AFP design file (as originally planned).
        *   Alternatively, have separate content fields like `html_content`, `text_content`, `json_payload_structure`.
    *   **APIs:**
        *   Existing APIs for creating/managing templates should accept `channel_type`.
        *   The response for `GET /templates/{template_id}` will return the content structure appropriate for its `channel_type`.
*   **Visual Template Builder Considerations:**
    *   **Email:** The existing visual builder for email (if based on HTML) can remain largely the same.
    *   **SMS:**
        *   A simpler text editor interface.
        *   Placeholder support `{{variable}}`.
        *   Character count display, warnings for multi-part messages.
        *   Preview of how the SMS might look.
    *   **App Push:**
        *   Fields for Title, Body.
        *   Interface to add custom key-value data pairs.
        *   Fields for image URL, deep link URL.
        *   Preview for different device OS (iOS, Android).
    *   **AFP:** The existing XSL-FO based or visual AFP designer.
    *   The builder needs to output a JSON representation of the template content that the `TemplateManagementService` can store and the respective sender service can interpret. For SMS and AppPush, this JSON might be simpler than XSL-FO for AFP or HTML for email.

## 6. Privacy Compliance Strategy (GDPR/PDPA)

*   **Consent Management:**
    *   The `CustomerProfileService` is central to managing consent.
    *   Explicit `opt_in_status` per `communication_type` and potentially per channel within that type.
    *   Timestamping and sourcing of all consent changes.
    *   Ability to distinguish between consent for marketing vs. transactional communications.
*   **Data Subject Rights:**
    *   **Access:** APIs on `CustomerProfileService` (`GET /customers/{customer_id}`) allow retrieval of all stored contact details, preferences, and consent records.
    *   **Rectification:** `PUT` APIs on `CustomerProfileService` allow customers to update their contact details and preferences.
    *   **Erasure ("Right to be Forgotten"):**
        *   A process needs to be defined to handle erasure requests. This involves:
            *   Deleting or anonymizing the customer's profile in `CustomerProfileService`.
            *   Propagating erasure requests to other services holding customer data (e.g., removing PII from logs after a certain period, though aggregated/anonymized operational metrics can be kept).
            *   This is complex and needs careful planning across all microservices.
*   **Audit Trails:**
    *   Log all changes to customer preferences and consent status in `CustomerProfileService`.
    *   Log all communication dispatch decisions and outcomes, linking back to the `CommunicationJob` and `customer_id`. This allows demonstrating what was sent, when, and under what consent basis.
    *   The `BatchOrchestrationService` should also maintain audit logs for batch job executions.
*   **Data Minimization:** Only collect and store customer contact details and preferences that are necessary for the defined communication purposes.
*   **Secure Storage:** All PII (contact details, tokens) must be stored securely, encrypted at rest and in transit.

## 7. Impact on Existing APIs and New API Requirements

*   **Impact on Previously Designed External APIs (from `RESTful_APIs_External_Integration_Design.md`):**
    *   **`GET /statements/{statement_id}/status`**:
        *   The `status` field might need more granular values to reflect the multi-channel dispatch process (e.g., "Pending_Dispatch", "Dispatched_To_SMS", "Delivered_To_Push_Device").
        *   The `details` field could indicate the channel used.
    *   **`GET /emails/{email_id}/status`**: This endpoint becomes more specific. If the system now handles multiple channels, a more generic endpoint might be needed, or this remains specifically for the email channel's part of a communication job. Perhaps rename to `GET /communication_attempts/{attempt_id}/status` where an attempt is channel-specific. For now, assume `email_id` refers to the email attempt within a broader `CommunicationJob`.
    *   **`POST /statements/{statement_id}/resend_email`**: This should be generalized to `POST /communication_jobs/{job_id}/resend` or `POST /statements/{statement_id}/resend_communication`.
        *   The request body could specify which channel to resend on, or let the `DispatchService` re-evaluate.
        ```json
        // POST /communication_jobs/{job_id}/resend
        {
          "channel_override": "sms", // Optional: force a specific channel
          "recipient_details_override": { ... } // Optional
        }
        ```
    *   **`POST /statements/reissue`**: This API is for full reprocessing from AFP generation. Its core function remains, but the subsequent delivery will now go through the new multi-channel `DispatchService`. The status updates related to delivery will be richer.
*   **New API Requirements (External Facing, via API Gateway):**
    *   **Submit Generic Communication Job:**
        *   `POST /communication_jobs`
        *   **Description:** Submits a new communication job to the platform, allowing the system to determine the best channel(s) based on customer preferences and rules.
        *   **Request Body Schema:** Similar to the `CommunicationJob` structure defined in Section 1 (excluding internal status fields).
            ```json
            {
              "correlation_id": "client_corr_id_001",
              "customer_id": "cust_789",
              "communication_type": "APPOINTMENT_REMINDER",
              "requested_channels": ["sms", "email"], // Optional hint
              "payload_data": { "customer_name": "Jane Roe", "appointment_time": "2025-02-10T15:00:00Z" },
              "template_references": {
                "sms": "sms_appt_reminder_v1",
                "email": "email_appt_reminder_v1"
              },
              "schedule_at": "2025-02-09T10:00:00Z" // Optional
            }
            ```
        *   **Success Response:** `202 Accepted` with `{ "job_id": "new_job_id_xyz" }`.
    *   **Manage Customer Preferences (subset of `CustomerProfileService` APIs exposed externally):**
        *   `GET /profiles/me/preferences`: (Assuming "me" is resolved via client's OAuth token to a `customer_id`) Retrieve preferences for the authenticated customer.
        *   `PUT /profiles/me/preferences`: Update preferences for the authenticated customer.
        *   `GET /profiles/me/contact_details`: Retrieve contact details.
        *   `POST /profiles/me/contact_details`: Add a new contact detail.
        *   `PUT /profiles/me/contact_details/{contact_id}`: Update a contact detail.
        *   These endpoints allow external systems (e.g., a customer-facing web portal) to manage preferences if the `CustomerProfileService` is not directly exposed or if a more controlled external API is desired.
*   **Internal APIs:**
    *   The new sender services (`SMSSenderService`, `AppPushService`) will need internal APIs or queue listeners for requests from the `DispatchService`.
    *   The `DispatchService` will need internal APIs to query `CustomerProfileService` and `TemplateManagementService`.

This document outlines the extension to a multi-channel electronic communication platform. Integration with AFP and Email systems means the `DispatchService` can choose these as channels, and the respective sender services (existing `EmailSenderService` and the new ones) would handle the final delivery. AFP generation and conversion would still occur as previously designed, with the output (e.g., a PDF from AFP conversion) becoming an attachment or linked content in one of the communication channels.The design document "Extending the System to an Electronic Communication Platform" has been created. It covers:

1.  **Generalized Communication Concept:** Defines a `CommunicationJob` structure with attributes for multi-channel processing.
2.  **New Sender Microservices Design:** Outlines `SMSSenderService` (integrating with SMS gateways like Twilio) and `AppPushService` (integrating with FCM/APNs), including their architecture, functionalities, and template handling.
3.  **Customer Preference Management:** Details a `CustomerProfileService` with a data model and APIs for managing customer contact details across channels, communication preferences per type, and consent records.
4.  **Channel Selection and Dispatch Logic:** Proposes a `DispatchService` responsible for consuming `CommunicationJob`s, fetching preferences, applying channel selection rules (including fallbacks), and dispatching to the appropriate sender services.
5.  **Template Management Enhancements:** Describes how the `TemplateManagementService` will be extended to support SMS and App Push templates (text-based and structured JSON, respectively) and considerations for the visual template builder.
6.  **Privacy Compliance Strategy:** Highlights features for GDPR/PDPA, focusing on consent management, data subject rights (access, rectification, erasure), audit trails, and data minimization.
7.  **Impact on Existing APIs and New API Requirements:** Discusses necessary modifications to previously designed external APIs (for statement status, email resend) and specifies new APIs for submitting generic communication jobs and managing customer preferences/contacts.

The document explains how these new capabilities integrate with the existing AFP and email functionalities, primarily through the `DispatchService` which can now orchestrate communications across a wider range of channels.

I will now submit the report for this subtask.
