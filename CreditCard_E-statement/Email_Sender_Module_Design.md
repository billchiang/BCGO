# Email Sender Module - Design Document

## 1. Proposed Architecture

*   **Microservice Design:** The module will be implemented as a standalone microservice named `EmailSenderService`.
    *   **Responsibilities:**
        *   Accepting email sending requests.
        *   Queuing emails for delivery.
        *   Managing the sending process via a custom SMTP client logic.
        *   Handling retries and basic bounce information.
        *   Providing status updates.
        *   Implementing deliverability best practices (SPF, DKIM signing).
    *   **Technology Stack:** Can be implemented in Java, Python, or .NET, leveraging appropriate libraries for each. The design will be language-agnostic where possible, with specific library recommendations.
*   **Receiving Email Requests:**
    *   **Primary Method: API Endpoint:**
        *   A RESTful API (e.g., `POST /send_email`) will be the primary way to submit email requests.
        *   **Payload (JSON):**
            ```json
            {
              "request_id": "unique_identifier_for_tracking", // Optional, can be generated by service if not provided
              "from_address": "sender@example.com",
              "reply_to_address": "reply-to@example.com", // Optional
              "to_addresses": ["recipient1@example.net", "recipient2@example.org"],
              "cc_addresses": ["cc1@example.net"], // Optional
              "bcc_addresses": ["bcc1@example.net"], // Optional
              "subject": "Your Subject Line",
              "body_plain": "This is the plain text body.",
              "body_html": "<h1>This is the HTML body</h1><p>With a <a href='http://example.com'>link</a>.</p>", // Optional
              "attachments": [ // Optional
                {
                  "filename": "document.pdf",
                  "content_type": "application/pdf",
                  "data_base64": "BASE64_ENCODED_DATA_HERE" // For direct embedding
                },
                {
                  "filename": "report.docx",
                  "download_url": "https://example.com/downloads/report.docx" // For linking
                }
              ],
              "headers": { // Optional custom headers
                "X-Custom-Header": "Value"
              },
              "priority": "normal" // Optional: "high", "normal", "low"
            }
            ```
        *   **Response (Synchronous):**
            *   On successful queuing: `202 Accepted` with a `message_id` (generated by the service for tracking).
            *   On validation error: `400 Bad Request` with error details.
            *   On authentication/authorization error: `401 Unauthorized` or `403 Forbidden`.
    *   **Alternative Method: Message Queue (e.g., RabbitMQ, Kafka, AWS SQS, Azure Service Bus):**
        *   The `EmailSenderService` can also consume messages directly from a designated queue.
        *   The message payload would be identical to the API JSON payload.
        *   This is suitable for high-throughput scenarios or integrating with other backend systems that prefer queue-based communication.
        *   The choice of queue will be determined by the overall system architecture but RabbitMQ is a good general-purpose starting point.

## 2. Custom SMTP Client Implementation Details

The goal is to send emails directly to recipient MX servers, but also support sending via a pre-configured relay if necessary (e.g., for specific domains or during initial rollout/testing).

*   **Core SMTP Protocol Support:**
    *   Implementation of standard SMTP commands: `HELO`/`EHLO`, `MAIL FROM`, `RCPT TO`, `DATA`, `QUIT`, `RSET`, `NOOP`.
    *   Parsing and handling of SMTP server responses (status codes and messages).
    *   Support for ESMTP extensions advertised by servers (e.g., `PIPELINING`, `8BITMIME`, `SMTPUTF8` if feasible).
*   **DNS MX Record Lookup Strategy:**
    *   For a given recipient email address (e.g., `user@example.com`):
        1.  Extract the domain part (`example.com`).
        2.  Perform a DNS query for MX records of that domain.
        3.  Order the MX records by their preference value (lower is more preferred).
        4.  Attempt connection to the MX servers in order of preference.
    *   **Caching:** Implement DNS caching (with appropriate TTL handling) to reduce redundant lookups for frequently targeted domains.
    *   **Libraries:**
        *   Java: `javax.naming.directory.DirContext` (for JNDI DNS lookups), or libraries like `dnsjava`.
        *   Python: `dnspython`.
        *   .NET: `System.Net.Dns` or third-party libraries like `DnsClient.NET`.
*   **Connection Management:**
    *   **Connection Pooling (Future Enhancement):** For high-volume sending to common domains, consider connection pooling to reduce SMTP handshake overhead. Initially, connections can be established per attempt.
    *   **TLS/SSL:**
        *   Prioritize `STARTTLS` on the standard SMTP port (25 or 587).
        *   If `STARTTLS` is not offered or fails, and if configured, attempt connection via SMTPS (SSL/TLS directly on port 465, though this is less standard for server-to-server).
        *   Use system's trusted CA certificates for server certificate validation. Allow configuration for accepting self-signed certificates for specific relays if absolutely necessary (development/testing environments only).
    *   **Timeouts:** Implement configurable timeouts for connection, command execution, and data transmission.
*   **Basic SMTP Authentication:**
    *   Support `AUTH PLAIN` and `AUTH LOGIN` mechanisms.
    *   This is primarily for scenarios where the service might be configured to send through an authenticated relay server (e.g., a corporate SMTP server, SendGrid, AWS SES) instead of direct MX delivery.
    *   Credentials would be securely stored and configured per relay.
*   **Recommended Libraries (for core SMTP client logic):**
    *   **Java:** **Jakarta Mail (formerly JavaMail)**. It provides `SMTPTransport` which handles much of the SMTP protocol. For MX lookups and direct sending, custom logic or `dnsjava` would supplement it.
    *   **Python:** **`smtplib`** for SMTP client operations. `dnspython` for MX lookups. For advanced bounce handling (server-side), `aiosmtpd` could be used to build a custom SMTP listener for NDRs (see Bounce Handling).
    *   **.NET:** **MailKit**. Its `SmtpClient` is robust, supports `STARTTLS`, authentication, and many ESMTP extensions. It can be used for direct sending (with custom MX lookup logic) or relaying.

## 3. Queue Management System

*   **Choice of Persistent Queue Technology:**
    *   **RabbitMQ (Recommended):**
        *   **Pros:** Mature, feature-rich (persistent messages, dead-letter exchanges, flexible routing), good client library support for Java, Python, .NET. Supports message acknowledgments critical for reliable processing.
        *   **Cons:** Requires separate server setup and management.
    *   **Apache Kafka:**
        *   **Pros:** Extremely high throughput, durable, good for streaming.
        *   **Cons:** More complex to set up and manage than RabbitMQ, might be overkill if not already part of the infrastructure.
    *   **Database-backed Queue (e.g., using PostgreSQL, MySQL):**
        *   **Pros:** Can leverage existing database infrastructure. Simpler for very basic needs.
        *   **Cons:** Less efficient for high volume, requires careful implementation of locking and polling, can put extra load on the database. Not recommended for a high-performance email sender.
    *   **Initial Recommendation:** **RabbitMQ** for its balance of features, reliability, and relative ease of use.
*   **Detailed Retry Mechanisms:**
    *   **Message Structure in Queue:** The queued message should include the email data and metadata like `attempt_count`, `last_attempt_time`, `original_enqueue_time`.
    *   **Temporary Errors (e.g., SMTP 4xx codes, connection timeouts, DNS lookup failures):**
        *   Increment `attempt_count`.
        *   Re-queue the message with a delay.
        *   **Retry Intervals:** Exponential backoff is recommended (e.g., 1 min, 5 min, 15 min, 30 min, 1 hour, then every few hours).
        *   **Max Retries:** Configurable (e.g., 10-15 attempts or up to 24-48 hours).
        *   If max retries are exhausted, move the message to a "failed" or "dead-letter" queue and log a permanent failure.
    *   **Permanent Errors (e.g., SMTP 5xx codes - unknown user, domain not found, message rejected by policy):**
        *   Log the permanent failure immediately.
        *   Move the message to a "failed" queue (or dead-letter exchange in RabbitMQ).
        *   No further retries for this specific recipient for this message.
*   **Bounce Handling Strategy:**
    *   **Synchronous SMTP Rejections:**
        *   These are immediate `5xx` (permanent) or `4xx` (temporary) responses received during the SMTP session (`RCPT TO` or `DATA` phases).
        *   Handled directly by the SMTP client logic as described in "Retry Mechanisms."
        *   Status is updated in the tracking database immediately.
    *   **Asynchronous Non-Delivery Reports (NDRs) / Bounces:**
        *   These are emails sent back to the `MAIL FROM` address (or a custom `Return-Path`) after the initial SMTP session has closed.
        *   **Initial Implementation (Feasible):**
            *   Configure a dedicated mailbox (e.g., `bounces@yourdomain.com`) for the `Return-Path` header.
            *   Periodically, a separate process or a component within the `EmailSenderService` would connect to this mailbox (via POP3 or IMAP, using libraries like Jakarta Mail, MailKit, or Python's `poplib`/`imaplib`).
            *   Parse these NDR emails. Identifying the original message and recipient can be challenging but often involves parsing standard bounce formats (e.g., DSN - Delivery Status Notification, RFC 3464) or custom headers injected into the original outgoing email (e.g., `X-Message-ID`).
            *   Update the status of the original email in the tracking database.
        *   **Future Enhancements (More Complex):**
            *   **Custom SMTP Listener for Bounces:** Deploy a lightweight SMTP server (e.g., using Python's `aiosmtpd` or a simple Java SMTP server library) specifically to receive NDRs directly. This avoids polling a mailbox and allows real-time processing. This listener would parse the incoming NDR and update the database.
            *   **Advanced NDR Parsing:** Use specialized libraries or services for parsing various NDR formats, as they can be inconsistent across different mail servers.
            *   **Feedback Loop (FBL) Processing:** Register with major ISPs (Gmail, Outlook.com, Yahoo) for FBLs to receive reports about messages marked as spam by users. This requires specific email headers and an endpoint to receive these reports.
*   **Priority Settings and Concurrency Controls:**
    *   **Priority Queues:** RabbitMQ supports message priorities. The `EmailSenderService` can use separate queues for high, normal, and low priority emails, or a single queue with message priority properties.
    *   **Concurrency Controls:**
        *   **Per Service Instance:** Limit the number of concurrent SMTP connections a single instance of `EmailSenderService` can make (e.g., using a semaphore or a fixed-size thread pool).
        *   **Per Destination Domain (Future Enhancement):** Implement logic to limit concurrent connections and sending rates to specific recipient domains to avoid being flagged as spam (e.g., no more than X connections or Y messages/minute to `example.com`). This requires tracking active connections/rates per domain.

## 4. Status Tracking and Logging

*   **Database Schema (Conceptual - e.g., PostgreSQL/MySQL):**
    *   `emails` table:
        *   `id`: BIGSERIAL, Primary Key
        *   `message_id`: VARCHAR(255), Unique, Indexed (generated by service or from request)
        *   `request_id`: VARCHAR(255), Indexed (from initial API request, optional)
        *   `from_address`: VARCHAR(255)
        *   `subject`: TEXT
        *   `status`: VARCHAR(50) (e.g., "queued", "sending", "sent", "failed_temporary", "failed_permanent", "delivered_fbl_spam")
        *   `retry_count`: INTEGER, Default 0
        *   `last_attempt_time`: TIMESTAMP
        *   `queued_time`: TIMESTAMP, Default CURRENT_TIMESTAMP
        *   `sent_time`: TIMESTAMP, Nullable
        *   `error_message`: TEXT, Nullable (last error encountered)
        *   `priority`: VARCHAR(20), Default 'normal'
    *   `email_recipients` table:
        *   `id`: BIGSERIAL, Primary Key
        *   `email_id`: BIGINT, Foreign Key to `emails.id`
        *   `recipient_address`: VARCHAR(255)
        *   `recipient_type`: VARCHAR(10) ('to', 'cc', 'bcc')
        *   `status`: VARCHAR(50) (e.g., "queued", "sending", "sent", "failed_temporary", "failed_permanent", "bounced")
        *   `smtp_response_code`: INTEGER, Nullable
        *   `smtp_response_message`: TEXT, Nullable
        *   `last_update_time`: TIMESTAMP
    *   Indexes on `recipient_address` and `status` in `email_recipients` would be useful for querying.
*   **Logging Details:**
    *   **Comprehensive Logging:** Log all significant events using a structured logging format (e.g., JSON).
    *   **Events to Log:**
        *   Email request received (with critical parameters, excluding sensitive data like Base64 content directly).
        *   Email queued (with `message_id`).
        *   Attempting to send (with `message_id`, recipient, MX server).
        *   SMTP commands and responses (can be verbose, potentially enabled by a debug flag).
        *   Successful delivery to a recipient.
        *   Temporary failure (with error, `retry_count`).
        *   Permanent failure (with error).
        *   Message moved to dead-letter queue.
        *   Bounce received and processed.
        *   DKIM signing success/failure.
    *   **Log Levels:** Use appropriate log levels (INFO, WARN, ERROR, DEBUG).
    *   **Tools:** Standard logging libraries (Log4j2/SLF4j for Java, `logging` module for Python, Serilog/NLog for .NET).
*   **API for Status Querying:**
    *   `GET /status/{message_id}`: Returns the overall status of the email and the status for each recipient.
    *   `GET /status?recipient_email={email_address}`: (More advanced) Returns status for emails sent to a specific recipient.
    *   Response should include status, timestamps, and any error messages.

## 5. Email Content and Attachments

*   **MIME Message Construction:**
    *   Support `multipart/alternative` for sending both plain text and HTML versions of the email. The receiving client will choose which version to display.
    *   Support `multipart/mixed` when attachments are included.
    *   Correctly set `Content-Type` headers for all MIME parts.
    *   Handle character encodings properly (UTF-8 preferred for all text parts).
*   **Handling of Download Links:**
    *   If an attachment is specified with a `download_url`, the service will not embed the data.
    *   Instead, the URL will be inserted into the email body (plain and/or HTML) as a hyperlink.
    *   This is useful for very large files or for tracking downloads.
*   **Libraries for MIME Construction:**
    *   **Java:** **Jakarta Mail (MimeMessage, MimeBodyPart, MimeMultipart).**
    *   **Python:** **`email.mime` package** (`MIMEMultipart`, `MIMEText`, `MIMEApplication`, `MIMEImage`).
    *   **.NET:** **MimeKit** (comes with MailKit). It has comprehensive MIME creation capabilities (`MimeMessage`, `TextPart`, `MimePart`, `Multipart`).

## 6. Deliverability and Security Best Practices

*   **SPF (Sender Policy Framework):**
    *   **Implementation:** This is primarily a DNS setup. A TXT record needs to be created for the sending domain(s) (the domain in the `MAIL FROM` / `Return-Path` address).
    *   **Content:** The SPF record will list the IP addresses or hostnames of the `EmailSenderService` instances that are authorized to send email for the domain.
    *   **Responsibility:** While the service itself doesn't "implement" SPF, the deployment and operational procedures for the service must include guidance on setting up correct SPF records.
*   **DKIM (DomainKeys Identified Mail) Signing:**
    *   **Implementation:**
        1.  **Key Generation:** Generate a public/private key pair for DKIM signing.
        2.  **DNS Setup:** Publish the public key as a TXT record in DNS at a specific selector (e.g., `selector1._domainkey.yourdomain.com`).
        3.  **Signing Process:** Before sending an email, the `EmailSenderService` will:
            *   Construct the email message (headers and body).
            *   Canonicalize the headers and body according to DKIM specs.
            *   Generate a cryptographic signature of the canonicalized content using the private key.
            *   Add a `DKIM-Signature` header to the email, including the signature, domain, selector, and other parameters.
    *   **Libraries:**
        *   Java: Libraries like `java-dkim` or building upon BouncyCastle. Jakarta Mail itself does not have direct DKIM signing support, but can be used to add the header.
        *   Python: `dkimpy`.
        *   .NET: MailKit/MimeKit provides DKIM signing capabilities.
*   **DMARC (Domain-based Message Authentication, Reporting, and Conformance):**
    *   **Implementation:** This is also a DNS setup. A TXT record at `_dmarc.yourdomain.com`.
    *   **Content:** The DMARC record tells receiving servers what to do if SPF and/or DKIM checks fail (e.g., `p=none`, `p=quarantine`, `p=reject`). It also specifies addresses for receiving aggregate (`rua`) and forensic (`ruf`) reports.
    *   **Responsibility:** Operational procedure. The service should enable SPF and DKIM to make DMARC effective. Processing DMARC reports is a separate operational task to monitor deliverability.
*   **Rate Limiting:**
    *   **Internal Limiting:**
        *   Limit the number of concurrent connections per instance of `EmailSenderService`.
        *   Limit the number of messages processed from the queue per unit of time per instance.
    *   **Per-Domain Limiting (Future Enhancement):** Track sending rates to major recipient domains (Gmail, Outlook, Yahoo) and throttle sending if internal thresholds are exceeded to avoid being temporarily blocked. This is complex and requires distributed state if multiple sender instances are used.
*   **IP Reputation Management:**
    *   **Dedicated IP Addresses:** For high-volume sending, use dedicated IP addresses.
    *   **IP Warm-up:** Gradually increase sending volume from new IP addresses over days/weeks.
    *   **Monitoring Blacklists:** Regularly check if sending IPs are listed on major DNS blacklists (DNSBLs).
    *   **Handling Spam Complaints:** Process Feedback Loops (FBLs) and unsubscribe requests promptly.
    *   **Clean Mailing Lists:** Ensure recipients have opted-in. High bounce rates of unknown users can damage IP reputation.
    *   **Content Quality:** Avoid spammy content.
    *   **Reverse DNS (PTR Records):** Ensure sending IP addresses have valid PTR records that match the sending domain or a relevant subdomain.

This design document provides a comprehensive plan for the Email Sender Module. The choice of specific libraries and queue technologies will depend on the chosen programming language and existing infrastructure, but the principles outlined should guide development.The design document for the Email Sender Module has been successfully created. It covers the proposed microservice architecture, details for a custom SMTP client (including MX lookup, TLS, and authentication), queue management with retry and bounce handling strategies, status tracking, MIME message construction, and key deliverability/security best practices like SPF, DKIM, and DMARC.

---
## 正體中文 (Traditional Chinese)

# 電子郵件傳送模組 - 設計文件

## 1. 建議架構

*   **微服務設計：** 該模組將實作為名為 `EmailSenderService` 的獨立微服務。
    *   **職責：**
        *   接受電子郵件傳送請求。
        *   將電子郵件排入佇列等待傳送。
        *   透過自訂 SMTP 用戶端邏輯管理傳送程序。
        *   處理重試和基本退信資訊。
        *   提供狀態更新。
        *   實作傳送能力最佳實務 (SPF、DKIM 簽署)。
    *   **技術堆疊：** 可使用 Java、Python 或 .NET 實作，並為每種語言利用適當的函式庫。設計將盡可能與語言無關，並提供特定的函式庫建議。
*   **接收電子郵件請求：**
    *   **主要方法：API 端點：**
        *   RESTful API (例如 `POST /send_email`) 將是提交電子郵件請求的主要方式。
        *   **負載 (JSON)：**
            ```json
            {
              "request_id": "unique_identifier_for_tracking", // 選用，如果未提供，可由服務產生
              "from_address": "sender@example.com",
              "reply_to_address": "reply-to@example.com", // 選用
              "to_addresses": ["recipient1@example.net", "recipient2@example.org"],
              "cc_addresses": ["cc1@example.net"], // 選用
              "bcc_addresses": ["bcc1@example.net"], // 選用
              "subject": "Your Subject Line",
              "body_plain": "This is the plain text body.",
              "body_html": "<h1>This is the HTML body</h1><p>With a <a href='http://example.com'>link</a>.</p>", // 選用
              "attachments": [ // 選用
                {
                  "filename": "document.pdf",
                  "content_type": "application/pdf",
                  "data_base64": "BASE64_ENCODED_DATA_HERE" // 用於直接嵌入
                },
                {
                  "filename": "report.docx",
                  "download_url": "https://example.com/downloads/report.docx" // 用於連結
                }
              ],
              "headers": { // 選用自訂標頭
                "X-Custom-Header": "Value"
              },
              "priority": "normal" // 選用: "high", "normal", "low"
            }
            ```
        *   **回應 (同步)：**
            *   成功排入佇列：`202 Accepted` 並附帶 `message_id` (由服務產生用於追蹤)。
            *   驗證錯誤：`400 Bad Request` 並附帶錯誤詳細資訊。
            *   驗證/授權錯誤：`401 Unauthorized` 或 `403 Forbidden`。
    *   **替代方法：訊息佇列 (例如 RabbitMQ、Kafka、AWS SQS、Azure Service Bus)：**
        *   `EmailSenderService` 也可以直接從指定的佇列取用訊息。
        *   訊息負載將與 API JSON 負載相同。
        *   這適用於高輸送量情境或與偏好基於佇列通訊的其他後端系統整合。
        *   佇列的選擇將取決於整體系統架構，但 RabbitMQ 是一個良好的通用起點。

## 2. 自訂 SMTP 用戶端實作詳細資訊

目標是直接將電子郵件傳送到收件人 MX 伺服器，但也支援在必要時透過預先設定的中繼伺服器傳送 (例如，針對特定網域或在初始推出/測試期間)。

*   **核心 SMTP 通訊協定支援：**
    *   實作標準 SMTP 指令：`HELO`/`EHLO`、`MAIL FROM`、`RCPT TO`、`DATA`、`QUIT`、`RSET`、`NOOP`。
    *   剖析和處理 SMTP 伺服器回應 (狀態碼和訊息)。
    *   支援伺服器公告的 ESMTP 擴充功能 (例如，如果可行，支援 `PIPELINING`、`8BITMIME`、`SMTPUTF8`)。
*   **DNS MX 記錄查閱策略：**
    *   對於給定的收件人電子郵件地址 (例如 `user@example.com`)：
        1.  擷取網域部分 (`example.com`)。
        2.  對該網域的 MX 記錄執行 DNS 查詢。
        3.  依其優先順序值排列 MX 記錄 (值越低越優先)。
        4.  依優先順序嘗試連線到 MX 伺服器。
    *   **快取：** 實作 DNS 快取 (並適當處理 TTL)，以減少對經常目標網域的重複查閱。
    *   **函式庫：**
        *   Java：`javax.naming.directory.DirContext` (用於 JNDI DNS 查閱)，或像 `dnsjava` 這樣的函式庫。
        *   Python：`dnspython`。
        *   .NET：`System.Net.Dns` 或像 `DnsClient.NET` 這樣的第三方函式庫。
*   **連線管理：**
    *   **連線池 (未來增強功能)：** 對於向常用網域大量傳送，請考慮使用連線池以減少 SMTP 交握的額外負荷。最初，可以為每次嘗試建立連線。
    *   **TLS/SSL：**
        *   在標準 SMTP 連接埠 (25 或 587) 上優先使用 `STARTTLS`。
        *   如果未提供 `STARTTLS` 或失敗，且已設定，則嘗試透過 SMTPS (直接在連接埠 465 上使用 SSL/TLS，儘管這對於伺服器對伺服器而言不太標準) 進行連線。
        *   使用系統信任的 CA 憑證進行伺服器憑證驗證。如果絕對必要 (僅限開發/測試環境)，允許設定接受特定中繼伺服器的自我簽署憑證。
    *   **逾時：** 實作可設定的連線、指令執行和資料傳輸逾時。
*   **基本 SMTP 驗證：**
    *   支援 `AUTH PLAIN` 和 `AUTH LOGIN` 機制。
    *   這主要適用於服務可能設定為透過已驗證的中繼伺服器 (例如公司 SMTP 伺服器、SendGrid、AWS SES) 而非直接 MX 傳送來傳送的情境。
    *   憑證將安全儲存並為每個中繼伺服器進行設定。
*   **建議函式庫 (用於核心 SMTP 用戶端邏輯)：**
    *   **Java：Jakarta Mail (前身為 JavaMail)**。它提供 `SMTPTransport`，可處理大部分 SMTP 通訊協定。對於 MX 查閱和直接傳送，自訂邏輯或 `dnsjava` 將對其進行補充。
    *   **Python：`smtplib`** 用於 SMTP 用戶端操作。`dnspython` 用於 MX 查閱。對於進階退信處理 (伺服器端)，可以使用 `aiosmtpd` 建置自訂 SMTP 接聽器以處理 NDR (請參閱退信處理)。
    *   **.NET：MailKit**。其 `SmtpClient` 功能強大，支援 `STARTTLS`、驗證和許多 ESMTP 擴充功能。它可用於直接傳送 (搭配自訂 MX 查閱邏輯) 或中繼。

## 3. 佇列管理系統

*   **永續性佇列技術的選擇：**
    *   **RabbitMQ (建議)：**
        *   **優點：** 成熟、功能豐富 (永續性訊息、無效信件交換、彈性路由)，對 Java、Python、.NET 提供良好的用戶端函式庫支援。支援對於可靠處理至關重要的訊息確認。
        *   **缺點：** 需要單獨的伺服器設定和管理。
    *   **Apache Kafka：**
        *   **優點：** 極高的輸送量、耐用、適合串流。
        *   **缺點：** 設定和管理比 RabbitMQ 複雜，如果尚未成為基礎架構的一部分，則可能過於龐大。
    *   **資料庫支援的佇列 (例如使用 PostgreSQL、MySQL)：**
        *   **優點：** 可以利用現有的資料庫基礎架構。對於非常基本的需求而言更簡單。
        *   **缺點：** 對於高容量效率較低，需要仔細實作鎖定和輪詢，可能會對資料庫造成額外負載。不建議用於高效能電子郵件傳送器。
    *   **初步建議：RabbitMQ**，因其在功能、可靠性和相對易用性方面的平衡。
*   **詳細的重試機制：**
    *   **佇列中的訊息結構：** 排入佇列的訊息應包含電子郵件資料和中繼資料，如 `attempt_count`、`last_attempt_time`、`original_enqueue_time`。
    *   **暫時性錯誤 (例如 SMTP 4xx 代碼、連線逾時、DNS 查閱失敗)：**
        *   遞增 `attempt_count`。
        *   延遲後重新將訊息排入佇列。
        *   **重試間隔：** 建議使用指數退避 (例如 1 分鐘、5 分鐘、15 分鐘、30 分鐘、1 小時，然後每隔幾小時)。
        *   **最大重試次數：** 可設定 (例如 10-15 次嘗試或長達 24-48 小時)。
        *   如果達到最大重試次數，則將訊息移至「失敗」或「無效信件」佇列，並記錄永久性失敗。
    *   **永久性錯誤 (例如 SMTP 5xx 代碼 - 未知使用者、找不到網域、訊息遭原則拒絕)：**
        *   立即記錄永久性失敗。
        *   將訊息移至「失敗」佇列 (或 RabbitMQ 中的無效信件交換)。
        *   此訊息不再對此特定收件人進行重試。
*   **退信處理策略：**
    *   **同步 SMTP 拒絕：**
        *   這些是在 SMTP 工作階段 (`RCPT TO` 或 `DATA` 階段) 期間收到的即時 `5xx` (永久性) 或 `4xx` (暫時性) 回應。
        *   由 SMTP 用戶端邏輯直接處理，如「重試機制」中所述。
        *   狀態會立即在追蹤資料庫中更新。
    *   **非同步未傳送回報 (NDR) / 退信：**
        *   這些是在初始 SMTP 工作階段關閉後傳送回 `MAIL FROM` 地址 (或自訂 `Return-Path`) 的電子郵件。
        *   **初步實作 (可行)：**
            *   為 `Return-Path` 標頭設定專用信箱 (例如 `bounces@yourdomain.com`)。
            *   定期由單獨的程序或 `EmailSenderService` 中的元件連線到此信箱 (透過 POP3 或 IMAP，使用 Jakarta Mail、MailKit 或 Python 的 `poplib`/`imaplib` 等函式庫)。
            *   剖析這些 NDR 電子郵件。識別原始訊息和收件人可能具有挑戰性，但通常涉及剖析標準退信格式 (例如 DSN - 傳送狀態通知，RFC 3464) 或注入原始傳出電子郵件中的自訂標頭 (例如 `X-Message-ID`)。
            *   在追蹤資料庫中更新原始電子郵件的狀態。
        *   **未來增強功能 (更複雜)：**
            *   **用於退信的自訂 SMTP 接聽器：** 部署輕量級 SMTP 伺服器 (例如使用 Python 的 `aiosmtpd` 或簡單的 Java SMTP 伺服器函式庫) 以直接接收 NDR。這樣可以避免輪詢信箱並允許即時處理。此接聽器將剖析傳入的 NDR 並更新資料庫。
            *   **進階 NDR 剖析：** 使用專用函式庫或服務剖析各種 NDR 格式，因為它們在不同郵件伺服器之間可能不一致。
            *   **回饋迴圈 (FBL) 處理：** 向主要 ISP (Gmail、Outlook.com、Yahoo) 註冊 FBL，以接收使用者將訊息標記為垃圾郵件的報告。這需要特定的電子郵件標頭和接收這些報告的端點。
*   **優先順序設定與並行控制：**
    *   **優先順序佇列：** RabbitMQ 支援訊息優先順序。`EmailSenderService` 可以為高、中、低優先順序的電子郵件使用不同的佇列，或使用具有訊息優先順序屬性的單一佇列。
    *   **並行控制：**
        *   **每個服務執行個體：** 限制單一 `EmailSenderService` 執行個體可以建立的並行 SMTP 連線數 (例如使用號誌或固定大小的執行緒池)。
        *   **每個目標網域 (未來增強功能)：** 實作邏輯以限制對特定收件人網域的並行連線和傳送速率，以避免被標記為垃圾郵件 (例如，對 `example.com` 不超過 X 個連線或 Y 則訊息/分鐘)。如果使用多個寄件者執行個體，則需要分散式狀態。

## 4. 狀態追蹤與記錄

*   **資料庫結構描述 (概念性 - 例如 PostgreSQL/MySQL)：**
    *   `emails` 資料表：
        *   `id`：BIGSERIAL，主鍵
        *   `message_id`：VARCHAR(255)，唯一，已索引 (由服務產生或來自請求)
        *   `request_id`：VARCHAR(255)，已索引 (來自初始 API 請求，選用)
        *   `from_address`：VARCHAR(255)
        *   `subject`：TEXT
        *   `status`：VARCHAR(50) (例如 "queued"、"sending"、"sent"、"failed_temporary"、"failed_permanent"、"delivered_fbl_spam")
        *   `retry_count`：INTEGER，預設為 0
        *   `last_attempt_time`：TIMESTAMP
        *   `queued_time`：TIMESTAMP，預設為 CURRENT_TIMESTAMP
        *   `sent_time`：TIMESTAMP，可為 Null
        *   `error_message`：TEXT，可為 Null (遇到的最後一個錯誤)
        *   `priority`：VARCHAR(20)，預設為 'normal'
    *   `email_recipients` 資料表：
        *   `id`：BIGSERIAL，主鍵
        *   `email_id`：BIGINT，外鍵至 `emails.id`
        *   `recipient_address`：VARCHAR(255)
        *   `recipient_type`：VARCHAR(10) ('to'、'cc'、'bcc')
        *   `status`：VARCHAR(50) (例如 "queued"、"sending"、"sent"、"failed_temporary"、"failed_permanent"、"bounced")
        *   `smtp_response_code`：INTEGER，可為 Null
        *   `smtp_response_message`：TEXT，可為 Null
        *   `last_update_time`：TIMESTAMP
    *   `email_recipients` 中 `recipient_address` 和 `status` 的索引對於查詢很有用。
*   **記錄詳細資訊：**
    *   **全面記錄：** 使用結構化記錄格式 (例如 JSON) 記錄所有重要事件。
    *   **要記錄的事件：**
        *   收到電子郵件請求 (包含關鍵參數，不直接包含 Base64 內容等敏感資料)。
        *   電子郵件已排入佇列 (包含 `message_id`)。
        *   嘗試傳送 (包含 `message_id`、收件人、MX 伺服器)。
        *   SMTP 指令和回應 (可能很冗長，可透過偵錯旗標啟用)。
        *   成功傳送給收件人。
        *   暫時性失敗 (包含錯誤、`retry_count`)。
        *   永久性失敗 (包含錯誤)。
        *   訊息已移至無效信件佇列。
        *   收到並處理退信。
        *   DKIM 簽署成功/失敗。
    *   **記錄層級：** 使用適當的記錄層級 (INFO、WARN、ERROR、DEBUG)。
    *   **工具：** 標準記錄函式庫 (Java 的 Log4j2/SLF4j、Python 的 `logging` 模組、.NET 的 Serilog/NLog)。
*   **用於狀態查詢的 API：**
    *   `GET /status/{message_id}`：傳回電子郵件的整體狀態以及每個收件人的狀態。
    *   `GET /status?recipient_email={email_address}`：(更進階) 傳回傳送給特定收件人的電子郵件狀態。
    *   回應應包含狀態、時間戳記和任何錯誤訊息。

## 5. 電子郵件內容與附件

*   **MIME 訊息建構：**
    *   支援 `multipart/alternative` 以傳送電子郵件的純文字和 HTML 版本。接收用戶端將選擇要顯示的版本。
    *   包含附件時支援 `multipart/mixed`。
    *   為所有 MIME 部分正確設定 `Content-Type` 標頭。
    *   正確處理字元編碼 (所有文字部分建議使用 UTF-8)。
*   **下載連結的處理：**
    *   如果附件使用 `download_url` 指定，則服務不會嵌入資料。
    *   相反，URL 將作為超連結插入電子郵件內文 (純文字和/或 HTML) 中。
    *   這對於非常大的檔案或追蹤下載很有用。
*   **MIME 建構函式庫：**
    *   **Java：Jakarta Mail (MimeMessage、MimeBodyPart、MimeMultipart)。**
    *   **Python：`email.mime` 套件** (`MIMEMultipart`、`MIMEText`、`MIMEApplication`、`MIMEImage`)。
    *   **.NET：MimeKit** (隨附於 MailKit)。它具有全面的 MIME 建立功能 (`MimeMessage`、`TextPart`、`MimePart`、`Multipart`)。

## 6. 傳送能力與安全性最佳實務

*   **SPF (寄件者策略架構)：**
    *   **實作：** 這主要是一個 DNS 設定。需要為傳送網域 ( `MAIL FROM` / `Return-Path` 地址中的網域) 建立 TXT 記錄。
    *   **內容：** SPF 記錄將列出授權為該網域傳送電子郵件的 `EmailSenderService` 執行個體的 IP 位址或主機名稱。
    *   **職責：** 雖然服務本身不「實作」SPF，但服務的部署和營運程序必須包含有關設定正確 SPF 記錄的指南。
*   **DKIM (網域名稱金鑰識別郵件) 簽署：**
    *   **實作：**
        1.  **金鑰產生：** 為 DKIM 簽署產生公開/私密金鑰對。
        2.  **DNS 設定：** 在 DNS 中將公開金鑰發佈為特定選擇器 (例如 `selector1._domainkey.yourdomain.com`) 的 TXT 記錄。
        3.  **簽署程序：** 在傳送電子郵件之前，`EmailSenderService` 將：
            *   建構電子郵件訊息 (標頭和內文)。
            *   根據 DKIM 規格對標頭和內文進行規範化。
            *   使用私密金鑰產生規範化內容的加密簽章。
            *   在電子郵件中新增 `DKIM-Signature` 標頭，包括簽章、網域、選擇器和其他參數。
    *   **函式庫：**
        *   Java：像 `java-dkim` 這樣的函式庫或基於 BouncyCastle 建置。Jakarta Mail 本身不直接支援 DKIM 簽署，但可用於新增標頭。
        *   Python：`dkimpy`。
        *   .NET：MailKit/MimeKit 提供 DKIM 簽署功能。
*   **DMARC (基於網域的訊息驗證、報告和一致性)：**
    *   **實作：** 這也是一個 DNS 設定。在 `_dmarc.yourdomain.com` 建立 TXT 記錄。
    *   **內容：** DMARC 記錄告知接收伺服器如果 SPF 和/或 DKIM 檢查失敗該怎麼做 (例如 `p=none`、`p=quarantine`、`p=reject`)。它還指定接收彙總 (`rua`) 和鑑識 (`ruf`) 報告的地址。
    *   **職責：** 營運程序。服務應啟用 SPF 和 DKIM 以使 DMARC 生效。處理 DMARC 報告是監控傳送能力的單獨營運任務。
*   **速率限制：**
    *   **內部限制：**
        *   限制每個 `EmailSenderService` 執行個體的並行連線數。
        *   限制每個執行個體每單位時間從佇列處理的訊息數。
    *   **每個網域限制 (未來增強功能)：** 追蹤對主要收件人網域 (Gmail、Outlook、Yahoo) 的傳送速率，如果超過內部閾值，則限制傳送以避免被暫時封鎖。如果使用多個寄件者執行個體，這很複雜且需要分散式狀態。
*   **IP 信譽管理：**
    *   **專用 IP 位址：** 對於大量傳送，請使用專用 IP 位址。
    *   **IP 預熱：** 在幾天/幾週內逐步增加新 IP 位址的傳送量。
    *   **監控黑名單：** 定期檢查傳送 IP 是否列在主要 DNS 黑名單 (DNSBL) 上。
    *   **處理垃圾郵件投訴：** 及時處理回饋迴圈 (FBL) 和取消訂閱請求。
    *   **乾淨的郵寄清單：** 確保收件人已選擇加入。未知使用者的高退信率會損害 IP 信譽。
    *   **內容品質：** 避免垃圾郵件內容。
    *   **反向 DNS (PTR 記錄)：** 確保傳送 IP 位址具有與傳送網域或相關子網域相符的有效 PTR 記錄。

此設計文件為電子郵件傳送模組提供了全面的計畫。特定函式庫和佇列技術的選擇將取決於所選的程式語言和現有的基礎架構，但概述的原則應指導開發。
